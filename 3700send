#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2
# Henry Zhou
# Connor G
#

import sys
import socket
import time
import datetime
import select
import json

MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 30
SEQUENCE = 0
WINDOW_SIZE = 4000000  # default window size
SENT_PACKETS = {}  # key: SEQUENCE, values: (data, time)
RTTs = []  # stores all RTTs used for averaging
PACKET_TO = 500  # Dynamic value for packet timeouts dependant on RTTs, defaults to 500ms

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":") + 1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(TIMEOUT)
sock.setblocking(0)


def currMillis():
    """
    Helper method toget current time in ms
    """
    return int(round(time.time() * 1000))


def log(string):
    """
    Helper method for logging data
    """
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")


def send_next_packet():
    """
    sends the next packet and increments SEQUENCE
    :return:
    """
    global SEQUENCE

    data = sys.stdin.read(DATA_SIZE)
    if (len(data) > 0):
        msg = json.dumps({"sequence": SEQUENCE, "data": data, "ack": False, "eof": False, "retransmit": False})
        SENT_PACKETS[SEQUENCE] = (data, currMillis())
        SEQUENCE += len(data)

        if sock.sendto(msg, dest) < len(msg):
            log("[error] unable to fully send packet")
        else:
            log("[send data] " + str(SEQUENCE) + " (" + str(len(data)) + ")")
        return True
    else:
        return False


def checkTimeout():
    """
    Retransmits packet if it times out
    """
    global WINDOW_SIZE

    for key in SENT_PACKETS.iterkeys():
        data, time = SENT_PACKETS[key]
        if currMillis() - time > PACKET_TO:
            msg = json.dumps({"sequence": key, "data": data, "ack": False, "eof": False, "retransmit": True})
            SENT_PACKETS[key] = (data, currMillis())
            log("Retransmitting: " + str(key))
            sock.sendto(msg, dest)


def updateRTT(timeSent):
    """
    Updates the RTT depending on the last packet received
    """
    global PACKET_TO
    rtt = currMillis() - timeSent
    RTTs.append(rtt)
    PACKET_TO = (sum(RTTs) / float(len(RTTs))) * 2


def adjustWindowSize(numAcked):
    """
    Helper method for adjusting the window size depending on performance of last round of transmit
    """
    global WINDOW_SIZE

    grade = float(numAcked / (len(SENT_PACKETS) + numAcked))
    if grade == 0:
        WINDOW_SIZE = WINDOW_SIZE - len(SENT_PACKETS)
        log("dec")
    elif grade == 1.0:
        WINDOW_SIZE += 2 * numAcked
        log("inc")


def handlePackets(packets):
    """
    Appropriately handles acks, removes acked from sent packets and adjusts window size
    """
    global WINDOW_SIZE
    numAcked = 0

    for packet in packets:
        (data, addr) = packet
        try:
            decoded = json.loads(data)

            # If there is an ack, send next packet
            if decoded['ack']:
                numAcked += 1
                keyToRemove = ""

                for key in SENT_PACKETS.iterkeys():
                    adjustedSequence = key + len(SENT_PACKETS[key][0])
                    if (adjustedSequence == decoded['ack']):
                        keyToRemove = key

                ackedPacket = SENT_PACKETS.pop(keyToRemove, None)

                log("[recv ack] " + str(SEQUENCE))

                if ackedPacket is not None:
                    updateRTT(ackedPacket[1])
        except (ValueError, KeyError, TypeError):
            log("[recv corrupt packet]")

    adjustWindowSize(numAcked)


def sendPackets():
    """
    Sends packets depending on available space in the window
    :return:
    """
    global WINDOW_SIZE
    global SENT_PACKETS

    availableWindow = WINDOW_SIZE - len(SENT_PACKETS)
    log("available WINDOW_SIZE: " + str(availableWindow))
    for x in range(0, int(availableWindow)):
        if (not send_next_packet()):
            return False
            break
    return True


def endConnection():
    """
    Ends the connection when eof is reached, we found that it is worth to send more packets than to wait for timeout
    :return:
    """
    for x in range(0, 10):
        sock.sendto(json.dumps({"eof": True, "data": "", "sequence": SEQUENCE, "ack": False}), dest)
    sys.exit(0)


def readPackets():
    """
    Reads data from socket
    """
    readable, writable, exceptional = select.select([sock], [], [], float(PACKET_TO / 1000))
    result = []

    for s in readable:
        try:
            while True:
                data = s.recvfrom(MSG_SIZE)

                if not data:
                    break
                result.append(data)
        except:
            log("No data, not fatal")
    return result


# obligatory send next packet
send_next_packet()

# Main loop
while SENT_PACKETS:
    result = readPackets()
    checkTimeout()
    handlePackets(result)
    sendPackets()

endConnection()
